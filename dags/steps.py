from typing import Any, Dict

import mlflow
import mlflow.sklearn
import numpy as np
from hyperopt import fmin, hp, rand, tpe
from mlflow.models import infer_signature
from mlflow.tracking.client import MlflowClient
from sklearn.linear_model import ElasticNet
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

MODEL_NAME = "ElasticNetModel"
def eval_metrics(actual, pred):
    rmse = np.sqrt(mean_squared_error(actual, pred))
    mae = mean_absolute_error(actual, pred)
    r2 = r2_score(actual, pred)
    return rmse, mae, r2


def hyperparameter_tuning(dataset, max_runs, metric, algo):
    def eval_fn():
        def eval(params):
            alpha, l1_ratio = params
            run_id = train_model(alpha, l1_ratio, dataset)
            client = MlflowClient()
            training_run = client.get_run(run_id)
            metrics = training_run.data.metrics
            # return validation loss which will be used by the optimization algorithm
            valid_loss = metrics["val_{}".format(metric)]
            return valid_loss

        return eval

    # define the search space for hyper-parameters
    space = [
        hp.uniform("alpha", 0.1, 0.9),
        hp.uniform("l1_ratio", 0.1, 0.9),
    ]
    with mlflow.start_run() as run:
        exp_id = run.info.experiment_id
        # run the optimization algorithm
        best = fmin(
            fn=eval_fn(),
            space=space,
            algo=tpe.suggest if algo == "tpe.suggest" else rand.suggest,
            max_evals=max_runs,
        )
        mlflow.set_tag("best params", str(best))
        # find all runs generated by this search
        client = MlflowClient()
        query = "tags.mlflow.parentRunId = '{run_id}' ".format(run_id=run.info.run_id)
        best_run = client.search_runs([exp_id], query, order_by=[f"metrics.val_{metric} ASC"])[0]
        mlflow.set_tag("best_run", best_run.info.run_id)
        return best_run.info.run_id


def train_model(alpha: float, l1_ratio: float, dataset: Dict[str, Any]) -> str:
    train_x = dataset["train_x"]
    train_y = dataset["train_y"]
    val_x = dataset["val_x"]
    val_y = dataset["val_y"]
    test_x = dataset["test_x"]
    test_y = dataset["test_y"]
    with mlflow.start_run(nested=True) as run:
        lr = ElasticNet(alpha=alpha, l1_ratio=l1_ratio, random_state=42)
        mlflow.log_param("alpha", alpha)
        mlflow.log_param("l1_ratio", l1_ratio)
        lr.fit(train_x, train_y)

        pred_y = lr.predict(train_x)
        (rmse, mae, r2) = eval_metrics(train_y, pred_y)
        mlflow.log_metric("train_rmse", rmse)
        mlflow.log_metric("train_r2", r2)
        mlflow.log_metric("train_mae", mae)

        pred_y = lr.predict(val_x)
        (rmse, mae, r2) = eval_metrics(val_y, pred_y)
        mlflow.log_metric("val_rmse", rmse)
        mlflow.log_metric("val_r2", r2)
        mlflow.log_metric("val_mae", mae)

        pred_y = lr.predict(test_x)
        (rmse, mae, r2) = eval_metrics(test_y, pred_y)
        mlflow.log_metric("test_rmse", rmse)
        mlflow.log_metric("test_r2", r2)
        mlflow.log_metric("test_mae", mae)

        signature = infer_signature(test_x, pred_y)
        mlflow.sklearn.log_model(lr, "model", signature=signature)

    return run.info.run_id


def register_model(mlflow_run_id: str) -> str:
    model_version = mlflow.register_model(f"runs:/{mlflow_run_id}/model",MODEL_NAME)
    return model_version.version


def deploy_model(model_version: str):
    client = MlflowClient()
    client.transition_model_version_stage(
        name="ElasticNetModel",
        version=model_version,
        stage="Production",
        archive_existing_versions = True
    )